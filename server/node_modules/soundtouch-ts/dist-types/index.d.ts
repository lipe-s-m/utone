declare class AbstractFifoSamplePipe {
    inputBuffer: FifoSampleBuffer | null;
    outputBuffer: FifoSampleBuffer | null;
    constructor(createBuffers: boolean);
    clear(): void;
}
declare class RateTransposer extends AbstractFifoSamplePipe {
    rate: number;
    slopeCount: number;
    prevSampleL: number;
    prevSampleR: number;
    constructor(createBuffers: boolean);
    _reset(): void;
    process(): void;
    _transpose(numFrames: number): number;
}
declare class FifoSampleBuffer {
    private _vector;
    private _position;
    private _frameCount;
    constructor();
    readonly vector: Float32Array;
    readonly position: number;
    readonly startIndex: number;
    readonly frameCount: number;
    readonly endIndex: number;
    clear(frameCount?: number): void;
    put(numFrames: number): void;
    putSamples(samples: Float32Array, position?: number, numFrames?: number): void;
    putBuffer(buffer: FifoSampleBuffer, position?: number, numFrames?: number): void;
    receive(numFrames?: number): void;
    receiveSamples(output: Float32Array, numFrames: number): void;
    extract(output: Float32Array, position: number, numFrames: number): void;
    ensureCapacity(numFrames: number): void;
    ensureAdditionalCapacity(numFrames: number): void;
    rewind(): void;
}
declare class Stretch extends AbstractFifoSamplePipe {
    sampleRate: number;
    sequenceMs: number;
    seekWindowMs: number;
    overlapMs: number;
    bQuickSeek: boolean;
    bMidBufferDirty: boolean;
    pRefMidBuffer: Float32Array;
    pMidBuffer: Float32Array | null;
    overlapLength: number;
    bAutoSeqSetting: boolean;
    bAutoSeekSetting: boolean;
    nominalSkip: number;
    skipFract: number;
    seekWindowLength: number;
    seekLength: number;
    sampleReq: number;
    private _tempo;
    constructor(createBuffers: boolean, sampleRate: number);
    clear(): void;
    _clearMidBuffer(): void;
    /**
     * Sets routine control parameters. These control are certain time constants
     * defining how the sound is stretched to the desired duration.
     *
     * 'sampleRate' = sample rate of the sound
     * 'sequenceMS' = one processing sequence length in milliseconds (default = 82 ms)
     * 'seekwindowMS' = seeking window length for scanning the best overlapping
     *      position (default = 28 ms)
     * 'overlapMS' = overlapping length (default = 12 ms)
     */
    setParameters(aSampleRate: number, aSequenceMS: number, aSeekWindowMS: number, aOverlapMS: number): void;
    /**
     * Sets new target tempo. Normal tempo = 'SCALE', smaller values represent slower
     * tempo, larger faster tempo.
     */
    tempo: any;
    readonly inputChunkSize: number;
    readonly outputChunkSize: number;
    /**
     * Calculates overlapInMsec period length in samples.
     */
    calculateOverlapLength(overlapInMsec: number): void;
    checkLimits(x: number, mi: number, ma: number): number;
    /**
     * Calculates processing sequence length according to tempo setting
     */
    calcSeqParameters(): void;
    /**
     * Enables/disables the quick position seeking algorithm.
     */
    quickSeek: boolean;
    /**
     * Seeks for the optimal overlap-mixing position.
     */
    seekBestOverlapPosition(): number;
    /**
     * Seeks for the optimal overlap-mixing position. The 'stereo' version of the
     * routine
     *
     * The best position is determined as the position where the two overlapped
     * sample sequences are 'most alike', in terms of the highest cross-correlation
     * value over the overlapping period
     */
    seekBestOverlapPositionStereo(): number;
    /**
     * Seeks for the optimal overlap-mixing position. The 'stereo' version of the
     * routine
     *
     * The best position is determined as the position where the two overlapped
     * sample sequences are 'most alike', in terms of the highest cross-correlation
     * value over the overlapping period
     */
    seekBestOverlapPositionStereoQuick(): number;
    /**
     * Slopes the amplitude of the 'midBuffer' samples so that cross correlation
     * is faster to calculate
     */
    precalcCorrReferenceStereo(): void;
    calcCrossCorrStereo(mixingPos: number, compare: Float32Array): number;
    /**
     * Overlaps samples in 'midBuffer' with the samples in 'pInputBuffer' at position
     * of 'ovlPos'.
     */
    overlap(ovlPos: number): void;
    /**
     * Overlaps samples in 'midBuffer' with the samples in 'pInput'
     */
    overlapStereo(pInputPos: number): void;
    process(): void;
}
declare class SoundTouch {
    rateTransposer: RateTransposer;
    tdStretch: Stretch;
    _inputBuffer: FifoSampleBuffer;
    _intermediateBuffer: FifoSampleBuffer;
    _outputBuffer: FifoSampleBuffer;
    _rate: number;
    _tempo: number;
    virtualPitch: number;
    virtualRate: number;
    virtualTempo: number;
    constructor(sampleRate: number);
    clear(): void;
    rate: number;
    rateChange(rateChange: number): void;
    tempo: number;
    tempoChange: number;
    pitch: number;
    pitchOctaves: number;
    pitchSemitones: number;
    readonly inputBuffer: FifoSampleBuffer;
    readonly outputBuffer: FifoSampleBuffer;
    _calculateEffectiveRateAndTempo(): void;
    process(): void;
}
export { RateTransposer, Stretch, SoundTouch };
